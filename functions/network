#!/usr/bin/env bash

include_header network

rdo_network() {
  eval "$(args::init_subcommand "rdo network" "Manage networks.")"

  args::new_command "clean" empty "Remove all networks" \
                    'rdo_network_clean "${@}"'
  args::new_command "ls" default "List networks" \
                    'rdo_network_ls "${@}"'

  args::new_command "address" default "Get network address" \
                    'rdo_network_address "${@}"'
  args::new_command "bridge" default "Get bridge name" \
                    'rdo_network_bridge "${@}"'
  args::new_command "interface-name" default "Get interface name" \
                    'rdo_network_interface_name "${@}"'
  args::new_command "prefix" default "Get network prefix" \
                    'rdo_network_prefix "${@}"'
  args::new_command "subnet" default "Get network subnet" \
                    'rdo_network_subnet "${@}"'

  # TODO: Move all iptables stuff into sub-command:
  args::new_command "iptables" default "Call iptables on docker host" \
                    'rdo_network_iptables "${@}"'
  args::new_command "iptables-flush" empty "Flush rdo-specific iptables rules on docker host" \
                    'rdo_network_iptables_flush'
  args::new_command "iptables-list" empty "List rdo-specific iptables rules on docker host" \
                    'rdo_network_iptables_list'
  args::new_command "iptables-save" default "Call iptables-save on docker host" \
                    'rdo_network_iptables_save "${@}"'

  args::new_command "forward" default "Add forward rules between networks" \
                    'rdo_network_forward "${@}"'
  args::new_command "isolate-network" default "Isolate network" \
                    'rdo_network_isolate_network "${@}"'
  args::new_command "nat" default "Add nat rules between networks" \
                    'rdo_network_nat "${@}"'

  args::new_command "tc" default "Call tc on docker host" \
                    'rdo_network_tc "${@}"'
  args::new_command "tc-replace-root-tbf" default "Replace tc root tbf rule of node" \
                    'rdo_network_tc_replace_root_tbf "${@}"'
  args::new_command "tc-del-root" default "Delete root rule of node" \
                    'rdo_network_tc_del_root "${@}"'

  eval "$(args::process)"
}

rdo_network_clean() {
  rdo_network_iptables_flush || true

  local networks
  mapfile -t networks < <(rdo_network_ls --quiet --no-trunc)

  if (( ${#networks[@]} > 0 )); then
    docker network rm "${networks[@]}"
  fi
}

rdo_network_ls() {
  docker network ls --filter "label=project=rdo" "${@}"
}

rdo_network_address() {
  local subnet
  subnet="$(rdo_network_subnet "${@}")"
  echo "${subnet%%/*}"
}

rdo_network_bridge() {
  local name="${1:?Missing name argument.}"
  local network_id
  network_id="$(docker network inspect --format {{.Id}} "${name}")"

  echo "br-${network_id:0:12}"
}

rdo_network_interface_name() {
  # eval "$(args::init_options_string "rdo network interface-name NODE-NAME" "node_name" "Get node's interface name.")"

  # args::new_option "ifname" string "" "Node interface name" 'local ifname="eth0"' 'ifname="${args__1}"'

  # eval "$(args::process)"

  # start of generated bash args 'rdo network interface-name NODE-NAME'

  local ifname="eth0"

  while true; do
    case "${1}" in
      --ifname)
        local args__1="${2:?Missing argument for '${1}'.}"
        shift 2
        ifname="${args__1}"
        ;;
      --help|-h)
        echo "Usage: rdo network interface-name NODE-NAME"
        echo
        echo "Get node's interface name."
        echo
        echo "Options:"
        echo "      --ifname   Node interface name"
        echo
        echo "Run 'rdo network interface-name NODE-NAME COMMAND --help' for more information on a command."
        exit 0
        ;;
      *)
        if [[ -n "${1}" ]] && [[ -z "${1##-*}" ]]; then
          print_error "${args__root}: unknown flag: ${1}"
          return 1
        fi

        break
        ;;
    esac
  done

  if (( ${#} > 1 )); then
    print_error "rdo network interface-name NODE-NAME: too many arguments"
    exit 1
  fi

  if (( ${#} == 0 )) || [[ -z "${1}" ]]; then
    print_error "rdo network interface-name NODE-NAME: missing or empty argument"
    exit 1
  fi

  local node_name="${1}"
  shift

  # end of generated bash args 'rdo network interface-name NODE-NAME'

  local sandbox_key ip_entry
  sandbox_key="$(docker inspect --format '{{ .NetworkSettings.SandboxKey }}' "${node_name}")"
  ip_entry="$(rdo__call_host sudo nsenter --net="${sandbox_key}" -- ip -oneline link show dev "${ifname}")"

  if ! [[ "${ip_entry}" =~ ^[0-9]*:\ [^@\ ]*@if([0-9]*):\ [^$]*$ ]]; then
    exit 1
  fi

  if ! [[ "$(rdo__call_host ip -oneline link show)" =~ [0-9]*:\ ([^@\ ]*)@if$(( BASH_REMATCH[1] - 1 )):\  ]]; then
    exit 1
  fi

  echo "${BASH_REMATCH[1]}"
}

rdo_network_prefix() {
  local subnet
  subnet="$(rdo_network_subnet "${@}")"
  echo "${subnet##*/}"
}

rdo_network_subnet() {
  local name="${1:?Missing name argument.}"
  docker network inspect --format '{{ (index .IPAM.Config 0).Subnet }}' "${name}"
}

rdo_network_iptables() {
  print_normal iptables "${@}"
  rdo__call_host sudo iptables "${@}"
}

rdo_network_iptables_flush() {
  local rules nat_rules filter_rules
  nat_rules="$(rdo_network_iptables_list --table nat | sed -e 's/^-A /sudo iptables --table nat -D /')"
  filter_rules="$(rdo_network_iptables_list --table filter | sed -e 's/^-A /sudo iptables --table filter -D /')"
  rules="$(printf "%s\n%s\n" "${nat_rules}" "${filter_rules}")"

  if [[ -n "${rules}" ]]; then
    rdo__call_host bash -c "echo '${rules}'; ${rules}"
  fi
}

rdo_network_iptables_list() {
  rdo__call_host sudo iptables-save "${@}" | sed -n -e '/ -m comment --comment "rdo network/p'
}

rdo_network_iptables_save() {
  rdo__call_host sudo iptables-save "${@}"
}

rdo_network_forward() {
  eval "$(args::init_options_string "rdo network forward OUTER-NETWORK" "outer_network" "Add FORWARD route between networks.")"

  args::new_option "network" req_string "n" "Add inner network" 'local inner_networks=()' 'inner_networks+=("${args__1}")'

  eval "$(args::process)"

  if (( ${#inner_networks[@]} == 0 )); then
    print_error "rdo network nat: Missing inner networks."
    return 1
  fi

  local outer_network_bridge
  outer_network_bridge="$(rdo_network_bridge "${outer_network}")"

  local inner_network
  for inner_network in "${inner_networks[@]}"; do
    local inner_network_bridge
    inner_network_bridge="$(rdo_network_bridge "${inner_network}")"

    local default_iptables_args=(
      -m comment
      --comment "'rdo network forward ${inner_network}->${outer_network}'"
    )

    rdo_network_iptables "${default_iptables_args[@]}" -t filter -I DOCKER-USER -i "${outer_network_bridge}" -o "${inner_network_bridge}" -j ACCEPT
    rdo_network_iptables "${default_iptables_args[@]}" -t filter -I DOCKER-USER -i "${inner_network_bridge}" -o "${outer_network_bridge}" -j ACCEPT
  done
}

rdo_network_isolate_network() {
  eval "$(args::init_options_string "rdo network isolate-network NETWORK" "network" "Isolate network.")"

  eval "$(args::process)"

  local network_bridge
  network_bridge="$(rdo_network_bridge "${network}")"

  local default_iptables_args=(
    -m comment
    --comment "'rdo network isolate-network ${network}'"
  )

  rdo_network_iptables "${default_iptables_args[@]}" -t filter -I DOCKER-USER -i "${network_bridge}" ! -o "${network_bridge}" -j DROP
}

rdo_network_nat() {
  eval "$(args::init_options_empty "rdo network nat" "Add NAT route.")"

  args::new_option "bridge" string "" "Use bridge egress" 'local bridge_name' 'bridge_name="${args__1}"'
  args::new_option "network" req_string "" "Add inner network" 'local inner_networks=()' 'inner_networks+=("${args__1}")'
  args::new_option "veth" string2: "" "Use veth egress" 'local veth_node; local veth_ifname' 'veth_node="${args__1}"; veth_ifname="${args__2}"'

  eval "$(args::process)"

  local egress_ifname

  if [[ -n "${bridge}" ]]; then
    egress_ifname="$(rdo_network_bridge "${bridge_name}")"
  elif [[ -n "${veth_node}" ]]; then
    egress_ifname="$(cat "./run/current/nodes/${veth_node}/net/${veth_ifname}/ifveth")"
  else
    print_error "rdo network nat: missing egress type"
    exit 1
  fi

  if (( ${#inner_networks[@]} == 0 )); then
    print_error "rdo network nat: Missing inner networks."
    return 1
  fi

  local inner_network
  for inner_network in "${inner_networks[@]}"; do
    local inner_network_bridge
    local inner_network_index
    inner_network_bridge="$(rdo_network_bridge "${inner_network}")"
    inner_network_index="$(cat "./run/current/networks/${inner_network}"/index)"

    local mark=$(( 0x30000 + inner_network_index ))
    local default_iptables_args=(
      -m comment
      --comment "'rdo network nat ${inner_network}->${egress_ifname}'"
    )

    rdo_network_iptables "${default_iptables_args[@]}" -t nat -I POSTROUTING -m mark --mark "${mark}" -o "${egress_ifname}" -j MASQUERADE

    rdo_network_iptables "${default_iptables_args[@]}" -t filter -I DOCKER-USER -i "${inner_network_bridge}" -o "${egress_ifname}" -j ACCEPT
    rdo_network_iptables "${default_iptables_args[@]}" -t filter -I DOCKER-USER -i "${egress_ifname}" -o "${inner_network_bridge}" -m state --state RELATED,ESTABLISHED -j ACCEPT
    rdo_network_iptables "${default_iptables_args[@]}" -t filter -I DOCKER-USER -i "${inner_network_bridge}" -o "${egress_ifname}" -j MARK --set-mark "${mark}"
  done
}

rdo_network_tc() {
  rdo__call_host sudo tc "${@}"
}

rdo_network_tc_replace_root_tbf() {
  eval "$(args::init_options_default "rdo network tc-replace-root-tbf [NODE-NAME]..." "Replace tc root tbf rule of nodes.")"

  # Using rate < 8kbit kills docker containers.
  args::new_option "rate" req_string "" "Limit ingress traffic rate" \
                   'local rate' 'rate="${args__1}"'

  # TODO: TC and handshakes seem to cause issues with 8kbit.
  args::new_option "rate-epsilon" empty "" "Limit ingress traffic rate to lowest possible (200kbit)" \
                   'local rate' 'rate=200kbit; args__opt_value__rate=200kbit'

  eval "$(args::process)"

  local commands

  local node_name
  for node_name in "${@}"; do
    local node_ifname
    node_ifname="$(rdo_network_interface_name "${node_name}")"

    tc_command=(
      tc qdisc replace dev "'${node_ifname}'"
      root tbf
      rate "'${rate}'"
      latency 50ms

      # burst 1540 # causes(?) eh_no_peer_info when using NAT (tests/ci-throttle 9a0bd9c078381892f11c662a1f52a83855223334)
      burst 1540
    )

    commands+="$(echo "echo 'tc_replace_root_tbf/${node_name}/${node_ifname}/rate:${rate}' && ${tc_command[@]} && ")"
  done

  rdo__call_host sudo bash -c "\"${commands} : \""
}

rdo_network_tc_del_root() {
  # eval "$(args::init_options_default "rdo network tc-del-root [NODE-NAME]..." "Delete root rule of nodes.")"

  # eval "$(args::process)"

  # start of generated bash args 'rdo network tc-del-root [NODE-NAME]...'

  while true; do
    case "${1}" in
      --help|-h)
        echo "Usage: rdo network tc-del-root [NODE-NAME]..."
        echo
        echo "Delete root rule of nodes."
        echo
        echo "Run 'rdo network tc-del-root [NODE-NAME]... COMMAND --help' for more information on a command."
        exit 0
        ;;
      *)
        if [[ -n "${1}" ]] && [[ -z "${1##-*}" ]]; then
          print_error "${args__root}: unknown flag: ${1}"
          return 1
        fi

        break
        ;;
    esac
  done

  # end of generated bash args 'rdo network tc-del-root [NODE-NAME]...'

  local commands

  local node_name
  for node_name in "${@}"; do
    local node_ifname
    node_ifname="$(rdo_network_interface_name "${node_name}")"

    tc_command=(
      tc qdisc del dev "'${node_ifname}'"
      root
    )

    commands+="$(echo "echo 'tc_del_root/${node_name}/${node_ifname}' && ${tc_command[@]} && ")"
  done

  rdo__call_host sudo bash -c "\"${commands} : \""
}
