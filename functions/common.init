#!/usr/bin/env bash

include_header common.init

get_project_path() {
  if [[ -z "${PROJECT_PATH}" ]]; then
    print_error "cd_project_path: PROJECT_PATH variable not set"
    exit 1
  fi

  local project_path="$(cd "${PROJECT_PATH}" &> /dev/null && pwd -P)"

  if [[ "${project_path}" == "/" ]]; then
    print_error "cd_project_path: path is root"
    exit 1
  fi

  if [[ -z "${project_path}" ]]; then
    print_error "cd_project_path: failed to enter directory '${PROJECT_PATH}'"
    exit 1
  fi

  echo "${project_path}"
}

rdo_bash() {
  cd "${PROJECT_PATH}"

  if ! [[ -f "${DATA_PATH}/env.bash" ]]; then
    print_error "rdo bash: environment not initialized, could not find '${DATA_PATH}/env.bash'"
    exit 1
  fi

  print_progress "entering custom bash session"
  /usr/bin/env bash --init-file "${DATA_PATH}/env.bash"
  print_warning "exiting custom bash session"
}

#
# Refactor:
#

rdo__compare_id__file_image() {
  local file_name="${1:?Missing file argument.}"
  local image_name="${2:?Missing image argument.}"

  if ! [[ -f "${file_name}" ]]; then
    return 1
  fi

  local file_id="$(cat "${file_name}")"
  local image_id="$(rdo docker inspect --id "${image_name}")"

  [[ -n "${file_id}" ]] && [[ "${file_id}" == "${image_id}" ]]
}

rdo__compare_hash__dir_dir() {
  local path_lhs="${1:?Missing lhs path argument.}"
  local path_rhs="${2:?Missing rhs path argument.}"

  # Sort by size to detect if any files are empty or incomplete.

  if [[ "${path_lhs}" =~ : ]]; then
    local hash_lhs="$(docker exec "${path_lhs%%:*}" sh -c "cd '${path_lhs##*:}'; \ls -S | tail -n +2")"
  else
    local hash_lhs="$(cd "${path_lhs}"; \ls -S | tail -n +2)"
  fi

  if [[ "${path_rhs}" =~ : ]]; then
    local hash_rhs="$(docker exec "${path_rhs%%:*}" sh -c "cd '${path_rhs##*:}'; \ls -S | tail -n +2")"
  else
    local hash_rhs="$(cd "${path_rhs}"; \ls -S | tail -n +2)"
  fi

  [[ "${hash_lhs}" == "${hash_rhs}" ]]
}

# Move:

rdo__project_absolute_unix_path() {
  if [[ -z "${PROJECT_ABSOLUTE_UNIX_PATH}" ]]; then
    if [[ "${OSTYPE}" == "cygwin" ]]; then
      PROJECT_ABSOLUTE_UNIX_PATH="$(cd "${PROJECT_PATH}" && cygpath -au .)"
      PROJECT_ABSOLUTE_UNIX_PATH="/cygwin64${PROJECT_ABSOLUTE_UNIX_PATH%/}"
    else
      PROJECT_ABSOLUTE_UNIX_PATH="$(cd "${PROJECT_PATH}" && pwd)"
    fi
  fi

  echo "${PROJECT_ABSOLUTE_UNIX_PATH}"
}


#
# Refactor:
#

# TODO: Replace 'arg_namespace' with FUNCNAME[1].

# - namespace "${@}" && break || exit 1 ;;
rdo__args__check_unknown_flag() {
  local arg_namespace="${1:?Missing namespace argument.}"
  shift

  if [[ -z "${1##-*}" ]]; then
    print_error "${arg_namespace//_/ }: unknown flag: ${1}"
    return 1
  fi
}

# - namespace "${@}" && break || exit 1 ;;
rdo__args__check_empty() {
  local arg_namespace="${1:?Missing namespace argument.}"
  shift

  if [[ -z "${1##-*}" ]]; then
    print_error "${arg_namespace//_/ }: unknown flag: ${1}"
    return 1
  fi

  if [[ -n "${@}" ]]; then
    print_error "${arg_namespace//_/ }: junk at end of input: ${@}"
    return 1
  fi
}

rdo__args__check_valid_arg() {
  local arg_name="${1:?Missing name argument.}"

  if [[ -z "${!arg_name}" ]]; then
    print_error "Missing ${arg_name} argument."
    exit 1
  fi
}
