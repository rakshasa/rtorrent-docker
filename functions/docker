#!/usr/bin/env bash

set -e
local included_rdo_docker="yes"
# print_normal "included rdo_docker"

rdo_docker() {
  local cmd="${1}"; shift || :

  case "${cmd}" in
    args)
      rdo_docker_args "${@}"
      ;;
    build)
      rdo_docker_build "${@}"
      ;;
    children)
      rdo_docker_children "${@}"
      ;;
    clean)
      source "${PROJECT_PATH}/functions/docker.clean"
      rdo_docker_clean "${@}"
      ;;
    context)
      source "${PROJECT_PATH}/functions/docker.context"
      rdo_docker_context "${@}"
      ;;
    images)
      rdo_docker_images "${@}"
      ;;
    stage)
      rdo_docker_stage "${@}"
      ;;
    targets)
      rdo_docker_targets "${@}"
      ;;
    --help|-h|'')
      echo "Usage: do docker COMMAND"
      echo
      echo "Docker commands"
      echo
      echo "Commands"
      echo "  args      List all args in build targets"
      echo "  build     Build a container"
      echo "  targets   List all build targets"
      echo
      echo "Run 'do docker COMMAND --help' for more information on a command."
      ;;
    *)
      print_error "unknown docker command: ${@}"
      return 1
      ;;
  esac
}

rdo_docker_args() {
  cd "${PROJECT_PATH}/docker"

  local target_list=($(ls dockerfile.*[!~]))
  declare -A arg_list

  for arg in $(sed -nE 's/^ARG ([^=]*)[^$]*$/\1/p' "${target_list[@]}"); do
    arg_list[${arg}]="yes"
  done

  printf "%s\n" "${!arg_list[@]}"
}

rdo_docker_build() {
  local args=()
  local docker_prefix=()

  local arg_base_image=
  local arg_context="."
  local arg_dry_run=
  local arg_no_cache=
  local arg_post_exec=
  local arg_pre_exec=
  local arg_repository="${RDO_REPOSITORY:?Not in rdo bash session.}"
  local arg_rsync_args=
  local arg_stage_image=
  local arg_tag=
  local arg_tag_append=


  while [[ -n "${1}" ]]; do
    case "${1}" in
      --base-image)
        arg_base_image="${2:?Missing base image argument.}"
        shift 2 ;;
      --build-arg)
        args+=("--build-arg" "${2:?Missing build arg argument.}")
        shift 2 ;;
      --context)
        arg_context="./context/${2:?Missing context argument.}"
        shift 2 ;;
      --dry-run)
        arg_dry_run="yes"
        shift ;;
      --no-cache)
        arg_no_cache="yes"
        shift ;;
      --post-exec)
        arg_post_exec="${2:?Missing exec argument.}"
        shift 2 ;;
      --pre-exec)
        arg_pre_exec="${2:?Missing exec argument.}"
        shift 2 ;;
      --repository)
        arg_repository="${2:?Missing repository argument.}"
        shift 2 ;;
      --rsync-verbose)
        arg_rsync_args="-acmv"
        shift ;;
      --stage-image)
        arg_stage_image="${2:?Missing stage image argument.}"
        shift 2 ;;
      --tag)
        arg_tag="${2:?Missing tag argument.}"
        shift 2 ;;
      --tag-append)
        arg_tag_append="${2:?Missing tag argument.}"
        shift 2 ;;
      --help|-h)
        echo "Usage: rdo docker build COMMAND"
        echo
        echo "Build docker container"
        echo
        echo "Options:"
        echo "      --base-image      Select base image"
        echo "      --build-arg       Pass build argument to docker"
        echo "      --dry-run         Do not actually build the container"
        echo "      --stage-image     Select stage image"
        echo "      --repository      Set repository name"
        echo "      --rsync-verbose   Explain what rsync is doing"
        echo "      --tag             Set the image tag"
        echo "      --tag-append      Append to the image tag"
        echo
        echo "Run 'do build COMMAND --help' for more information on a command."
      ;;
      *)
        if [[ -z "${1##-*}" ]] || (( ${#} != 1 )); then
          echo "do docker build: invalid parameters: ${@}" 2> /dev/null
          exit 1
        fi

        break
        ;;
    esac
  done

  local image_name="${1:?Missing image name.}"
  local tag_full="${arg_repository}/${arg_tag:-${image_name}}"

  if [[ -z "${arg_tag_append}" ]] || [[ "${tag_full}" =~ : ]]; then
    tag_full+="${arg_tag_append}"
  else
    tag_full+=":${arg_tag_append}"
  fi

  args+=("--tag" "${tag_full}")
  args+=("--file" "./docker/dockerfile.${image_name//\//.}")

  [[ -n "${arg_dry_run}" ]] && docker_prefix+=("echo")

  [[ -n "${arg_no_cache}" ]] && args+=("--no-cache")
  [[ -n "${arg_base_image}" ]] && args+=("--build-arg" "BASE_IMAGE=${arg_base_image}")
  [[ -n "${arg_repository}" ]] && args+=("--build-arg" "REPOSITORY=${arg_repository}")
  [[ -n "${arg_rsync_args}" ]] && args+=("--build-arg" "RSYNC_ARGS=${arg_rsync_args}")
  [[ -n "${arg_stage_image}" ]] && args+=("--build-arg" "STAGE_IMAGE=${arg_stage_image}")
  [[ -n "${arg_tag_append}" ]] && args+=("--build-arg" "TAG_APPEND=${arg_tag_append}")

  print_progress "\nbuilding ${tag_full}"

  # Change cwd to PROJECT_PATH so that docker doesn't get confused by
  # absolute windows paths that might be ambigious.
  cd "${PROJECT_PATH}"

  if [[ -n "${arg_pre_exec}" ]]; then
    print_progress "calling pre exec '${arg_pre_exec}'"
    ${arg_pre_exec} "${tag_full}"
  fi

  if ! "${docker_prefix[@]}" docker build "${args[@]}" "${arg_context}"; then
    print_error "failed to build docker container '${tag_full}'"
    exit 1
  fi

  if [[ -n "${arg_post_exec}" ]]; then
    print_progress "calling post exec '${arg_post_exec}'"
    ${arg_post_exec} "${tag_full}"
  fi
}

rdo_docker_children() {
  while [[ -n "${1}" ]]; do
    local parent_tag="${1:?Missing parent tag argument.}"
    local parent_id="$(docker inspect --format '{{ .Id }}' "${parent_tag}")"
    shift

    if [[ -z "${parent_id}" ]]; then
      print_error "parent tag '${parent_tag}' not found"
      exit 1
    fi

    local image_list=($(docker inspect --format '{{ .ID }}_{{ .Parent }}' $(docker images --all --no-trunc --quiet --filter "since=${parent_id}")))
    local parent_list=()

    local iidx
    for (( iidx=${#image_list[@]}-1; iidx >= 0; iidx--)); do
      local image_pair=(${image_list[${iidx}]//_/ })

      local image_id="${image_pair[0]}"
      local image_parent="${image_pair[1]}"

      if [[ "${image_parent}" == "${parent_id}" ]]; then
        echo "${image_id}"
        parent_list+=("${image_id}")
        continue
      fi

      local pidx
      for (( pidx=0; pidx < ${#parent_list[@]}; pidx++ )); do
        local pidx_id="${parent_list[${pidx}]}"

        if [[ "${image_parent}" == "${pidx_id}" ]]; then
          echo "${image_id}"
          parent_list+=("${image_id}")
          break
        fi
      done
    done
  done
}

rdo_docker_images() {
  :
}

rdo_docker_stage() {
  rdo_docker context build --context-type "stage" --context-name "stage" "${@}"
}

rdo_docker_targets() {
  cd "${PROJECT_PATH}/docker"

  local target_list
  target_list=($(ls dockerfile.*[!~]))
  target_list=("${target_list[@]#dockerfile.}")

  printf "%s\n" "${target_list[@]//\./\/}"
}
